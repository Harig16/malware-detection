# USAGE
# python train.py --model model --epochs 100 --classes 9 --xlabel x.pkl --ylabel y.pkl

from keras.callbacks import TensorBoard
import time
from sklearn.datasets import make_classification
from keras.preprocessing.image import img_to_array
from keras.models import load_model
from keras.callbacks import ModelCheckpoint, EarlyStopping
from m_image import cm, graph, rc, pr

import imutils
import h5py
import numpy as np
import pandas as pd
import argparse
import pickle
from model_train.vgg import Vgg
from keras.preprocessing.image import ImageDataGenerator
from keras.optimizers import Adam
from keras.preprocessing.image import img_to_array
from sklearn.preprocessing import LabelBinarizer
from sklearn.model_selection import train_test_split
from model_metrics import m_f1, m_precision, m_recall, roc_callback

argprs = argparse.ArgumentParser()
argprs.add_argument("-M", "--model", required=True,
	help="path to output model")
argprs.add_argument("-E", "--epochs", required=True,
	help="no oe epochs")
argprs.add_argument("-C", "--classes", required=True,
	help="no of class")
argprs.add_argument("-X", "--xlabel", required=True,
	help="x label store in pickle")
argprs.add_argument("-Y", "--ylabel", required=True,
	help="y label store in pickle")
argprs.add_argument("-I", "--img_dims", required = True,
	help="image dimension such as 32, 64 etc...")
args = vars(argprs.parse_args())

img_dims = int(args["img_dims"])
EPOCHS = int(args["epochs"])
INIT_LR = 1e-3
BS = 32
IMAGE_DIMS = (img_dims, img_dims, 1)
n_classes = int(args["classes"])

print "Loading Pickle data..."
train_data = pickle.load(open(args["xlabel"], "rb"))
train_labels = pickle.load(open(args["ylabel"], "rb"))
train_data = np.array(train_data, dtype="float") / 255.0
train_labels = np.array(train_labels)

print "Label binarizer..."
lb = LabelBinarizer()
labels = lb.fit_transform(train_labels)

print "Splitting Data into train and test..."
(trainX, testX, trainY, testY) = train_test_split(train_data, labels, test_size=0.2, random_state=10)

time = str(time.time()).split(".")[0]
tensorboard = TensorBoard(log_dir="logs/{}".format(args["model"]+"-"+time))
print args["model"]+ "-" +time

model_name = args["model"]+"-{}.h5".format(time)
EarlyStopping(monitor='val_acc', patience= 10, mode='max', verbose=1)

callbacks = [ModelCheckpoint(model_name, monitor='val_acc', save_best_only = True, mode='max', verbose=0), tensorboard,
roc_callback(training_data=(trainX, trainY) ,validation_data=(testX, testY))]

print "Compiling model..."
model = Vgg.build(width=IMAGE_DIMS[1], height=IMAGE_DIMS[0],
	depth=IMAGE_DIMS[2], classes=len(lb.classes_))
opt = Adam(lr=INIT_LR, decay=INIT_LR / EPOCHS)
model.compile(loss="categorical_crossentropy", optimizer=opt, metrics=["accuracy", m_f1, m_precision, m_recall])

print("training network model...")
H = model.fit(trainX, trainY, batch_size=BS, epochs=EPOCHS, callbacks=callbacks, validation_data=(testX, testY), verbose=1)

print "ACC/LOSS Graph.."
graph(EPOCHS, H, model_name)
print "Completed..."

print "Model Evaluation..."
score = model.evaluate(testX, testY, verbose=1)
Test_loss = score[0]
Test_accuracy = score[1]
print "Test_Loss: {}, Test_accuracy: {}".format(Test_loss, Test_accuracy)

print "confusion_matrix..."
model_predict = model.predict(testX)
model_labels = sorted(list(set(train_labels)))
cm(testX, testY, model_predict, n_classes, model_labels, model_name)
print "Confusion Matrix image saved"

print "Precision and Recall..."
print pr(testY, model_predict)

print "ROC Curve..."
rc(testX, testY, n_classes, model_predict, model_labels, model_name)
print "ROC Curve image is saved"
